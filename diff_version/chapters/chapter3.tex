\chapter[Related Research]{Related Research} \label{ch:relatedwork}

In the studies that we perform in this thesis, we investigate the delays that are related to the
delivery of new software content to end users. We also investigate if such delays are related to the
release cycle strategies that are adopted by the development team. Therefore, in the following
sections we describe the related research about the management of issues (\ie triaging, addressing,
and integration of issues) and the comparison between rapid and traditional release cycles in
software engineering.

\section{Triaging Issues}
To \textit{triage} issues is the process of deciding which issues have to be addressed and assigning
the appropriate developer to them \cite{Anvik2006}. This decision depends of several factors, such
as the impact of the issue on the software, or how much effort is required to address the issue.
Projects receive a high number of issue reports, which is usually larger than the developer team.
Hence, effective triaging of issue reports is an important means of keeping up with user demands. 

Hooimeijer and Weimer \cite{Hooimeijer2007} built a model to classify whether or not an issue report
will be ``cheap'' or ``expensive'' to triage by measuring the quality of the report. Based on their
findings, the authors state that the effort required to maintain a software system could be reduced
by filtering out reports that are ``expensive'' to triage. Saha \etal \cite{Saha2014} studied long
lived issues, \ie issues that were not addressed for more than one year. They found that the time to
assign a developer and address such issues is approximately two years. Our research
(Chapters~\ref{ch:integrationdelay}~and~\ref{ch:rapidvstrad}) complements these prior studies by
investigating the time to integrate issues once they are addressed rather than the time to assign a
developer to handle the issue.

\section{Addressing Issues}
Once an issue is properly triaged, the assigned developer starts to address it. To estimate the time
required to address issues, some approaches used the similarity of an issue to existing issues
\cite{Weib2007,Zhang2013}, while others built prediction models using different machine learning
techniques \cite{Panjer2007,Anbalagan2009,Giger2010, Marks2011}. 

Kim and Whitehead~\cite{Kim2006} computed the time taken to address issues in ArgoUML and
PostgreSQL. They found that the median issue-fix time is about 200 days. Guo \etal~\cite{Guo2010}
used logistic regression model to predict the probability that an new issue will be fixed. The
authors trained the model on Windows Vista issues and achieved a precision of 0.68 and recall of
0.64 when predicting Windows 7 issue reports. These approaches focus on estimating the time required
to address an issue. In our studies (Chapters~\ref{ch:integrationdelay}), however, we investigate in
which release an addressed issue will be integrated. 

Recent empirical studies assess the relationship between the attributes used to build models for
estimating bug fix time. Bhattacharya and Neamtiu \cite{Bhattacharya2011} performed univariate and
multivariate regression analyses to capture the significance of four features in issue reports.
Their results indicate that more independent variables are required to build better prediction
models. 

Herraiz \etal~\cite{Herraiz2008} studied the mean time to close issues reported in Eclipse, and how
the severity and priority levels of the issues affect this time. In their study, the authors used
one way analysis of variance to group the different priority and severity levels used in Eclipse.
Based on their result, the authors suggest to reduce the severity and priority options to three
levels. 

Zhang \etal \cite{Zhang2012} investigated the delays incurred by developers in the issue addressing
process. To do such analyses, they extract the beginning and ending time of an issue 
from interaction logs. The authors investigated the impact of three dimensions related to
issues: issue reports, source code involved in the issue, and code changes that are required to
address the issue. They found that metrics such as severity, operating system, description of the
issue, and comments are likely to impact the delays in starting to address the issue and changing
the status to RESOLVED. 

As Zhang \etal \cite{Zhang2012}, we use attributes related to issue reports to build explanatory
models (Chapters~\ref{ch:integrationdelay}~and~\ref{ch:rapidvstrad}). However, our aim is to
understand which attributes play an important role in the delay of integrating addressed issues.  In
addition, we investigate why severity and priority levels are not relevant to distinguish issue
reports that are addressed and integrated in a release prior to others.

\section{Integrating Issues} 

Prior research has studied delays related to the integration and delivery of addressed issues to end
users. Jiang~\etal~\cite{Jiang2013} studied the integration process of the Linux kernel. They found
that 33\% of the code patches that were submitted to resolve issues are accepted into an official
Linux release after 3 to 6 months. In Chapter~\ref{ch:integrationdelay}, we find that although
issues are addressed well before an upcoming release they may still be delayed. Indeed, 98\% of
addressed issues in the Firefox system were delayed by at least one release.
Choetkiertikul~\etal~\cite{riskyissues2015a,riskyissues2015b} study the risk of issues introducing
delays to deliver new releases of a software project.  

The integration of addressed issues is costly. Rahman~and~Rigby~\cite{rahmanrelease} found that the
period to stabilize addressed issues can take from 45 to 93 days in the Linux kernel and from 56 to
149 days in Chrome. Jiang~\etal~\cite{jiangmuch} proposes the ISOMO model to measure the cost of
integrating a new patch into a host project. 

Similar to Jiang \etal\cite{Jiang2013}, we also investigate the integration of addressed issues.
However, we focus on the integration delay of issues that have been addressed and not if a patch is
more likely to be accepted than the others
(Chapters~\ref{ch:integrationdelay}~and~\ref{ch:rapidvstrad}). 

Differently from Rahman~and~Rigby~\cite{rahmanrelease} and
Choetkiertikul~\etal~\cite{riskyissues2015a,riskyissues2015b}, the focus of our research is on the
time to deliver new content to end users rather than analyzing the time to stabilize issues or the
risk that a particular issue may cause on a release to be delayed.  Also, our work complements the
aforementioned studies by investigating the impact that the adoption of a rapid release cycle may
have upon the integration delay of addressed issues (Chapter~\ref{ch:rapidvstrad}).

\section{Traditional vs. Rapid Releases}

Shifting from traditional releases to rapid releases has been shown to have an impact on software
quality and quality assurance activities. M\"antyl\"a~\etal~\cite{mantyla2014rapid} found that rapid
releases have more tests executed per day but with less coverage. The authors also found that the
number of testers decreased in rapid releases, which increased the test workload.
Souza~\etal~\cite{souza2014rapid} found that the number of reopened bugs increased by 7\% when
Firefox changed to a rapid release cycle. Souza~\etal~\cite{souzabackout} found that backout of
commits increased when rapid releases were adopted.  However, they note that such results may be due
to changes in the development process rather than the rapid release cycle --- the backout culture
was not widely adopted during the Firefox traditional releases.

It is not clear yet if rapid releases lead to faster fixing of bugs.
Baysal~\etal~\cite{baysal2011tale} found that bugs are fixed faster in Firefox traditional releases
when compared to fixes in the Chrome rapid releases. On the other hand,
Khomh~\etal~\cite{khomh2012faster} found that bugs are fixed faster in Firefox rapid releases when
compared to its traditional releases.  However, less bugs are fixed in rapid releases,
proportionally.

Rapid releases may cause users to adopt new versions of the software earlier.
Baysal~\etal~\cite{baysal2011tale} found that users of the Chrome browser are more likely to adopt
new versions of the system when compared to Firefox traditional releases.
Khomh~\etal~\cite{khomh2012faster} also found that the new versions of Firefox that were developed
using rapid releases were adopted more quickly than the versions under traditional releases.

Inspired by past work on the differences between rapid and traditional release cycles, we set out to
study the impact that the shift of release strategies has had on integration delay
(Chapter~\ref{ch:rapidvstrad}).

\section{Chapter Summary}

In this chapter, we survey the related research about delay to deliver new software content to end
users and the impact that release cycles have on this process. 
